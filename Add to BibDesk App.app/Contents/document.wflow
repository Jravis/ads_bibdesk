<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>246</string>
	<key>AMApplicationVersion</key>
	<string>2.1</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>Single</string>
					<key>Optional</key>
					<true />
					<key>Types</key>
					<array>
						<string>com.apple.applescript.text-object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0</string>
				<key>AMParameterProperties</key>
				<dict />
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>Single</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.text-object</string>
					</array>
				</dict>
				<key>AMRequiredResources</key>
				<array />
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Get Contents of Clipboard.action</string>
				<key>ActionName</key>
				<string>Get Contents of Clipboard</string>
				<key>ActionParameters</key>
				<dict />
				<key>Application</key>
				<array>
					<string>System</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.Get_Contents_of_Clipboard</string>
				<key>CFBundleVersion</key>
				<string>1.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<true />
				<key>CanShowWhenRun</key>
				<true />
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>AMAppleScriptAction</string>
				<key>InputUUID</key>
				<string>B0BC33DB-42F5-4147-9582-00F1C89F8A2F</string>
				<key>Keywords</key>
				<array />
				<key>OutputUUID</key>
				<string>C0AD8A52-3C8F-4DD5-9F9D-DA919C923008</string>
				<key>UUID</key>
				<string>59A79AF9-E315-4B2F-995D-248D03F6B9F5</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>System</string>
				</array>
				<key>arguments</key>
				<dict />
			</dict>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true />
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0.1</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>COMMAND_STRING</key>
					<dict />
					<key>CheckedForUserDefaultShell</key>
					<dict />
					<key>inputMethod</key>
					<dict />
					<key>shell</key>
					<dict />
					<key>source</key>
					<dict />
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run Shell Script.action</string>
				<key>ActionName</key>
				<string>Run Shell Script</string>
				<key>ActionParameters</key>
				<dict>
					<key>COMMAND_STRING</key>
					<string>#!/usr/bin/env python
"""
ADS to BibDesk -- frictionless import of ADS publications into BibDesk
Copyright (C) 2011  Rui Pereira &lt;rui.pereira@gmail.com&gt; and
                    Jonathan Sick &lt;jonathansick@mac.com&gt;

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Based on ADS to Bibdesk automator action by
Jonathan Sick, jonathansick@mac.com, August 2007

Input may be one of the following:
- ADS abstract page URL
- ADS bibcode
- arXiv abstract page
- arXiv identifier
"""
import sys
import os
import re
import time
import optparse
import tempfile
import socket

import cgi
import urllib2
import urlparse

import subprocess as sp
from HTMLParser import HTMLParser
from htmlentitydefs import name2codepoint

# default timeout for url calls
socket.setdefaulttimeout(30)

def main():
    """
    Parse options and launch main loop
    """
    parser = optparse.OptionParser()
    parser.add_option('-d', '--debug', dest="debug", default=False, action="store_true")
    options, articleID = parser.parse_args()

    # Get preferences from (optional) config file
    prefs = Preferences()
    if options.debug:
        prefs['debug'] = True

    # multiple arguments - bibcodes to compare with ADS
    if len(articleID) &gt; 1:
        changed = open('changed_arxiv', 'w')
        for n, bibcode in enumerate(articleID):
            # sleep for 10 seconds, to prevent ADS flooding
            time.sleep(10)
            if prefs['debug']:
                print "bibcode", bibcode
            # these are ADS bibcodes by default
            adsURL = urlparse.urlunsplit(('http', prefs['ads_mirror'], 'abs/%s' % bibcode, '', ''))
            if prefs['debug']:
                print "adsURL", adsURL
            # parse the ADS HTML file
            ads = ADSHTMLParser(prefs=prefs)
            ads.parse(adsURL)
            if prefs['debug']:
                print "ads.bibtex", ads.bibtex
            if ads.bibtex is None: # ADSHTMLParser failed
                if prefs['debug']:
                    print "FAILURE: ads.bibtex is None!"
                continue
            if ads.bibtex.bibcode != bibcode:
                print '%i. %s has become %s' % (n+1, bibcode, ads.bibtex.bibcode)
                print &gt;&gt; changed, bibcode
            else:
                print '%i. %s has not changed' % (n+1, bibcode)
                continue
        changed.close()

    # normal call
    else:
        # Determine what we're dealing with. The goal is to get a URL into ADS
        adsURL = parseURL(articleID[0], prefs)
        if adsURL is None:
            sys.exit()

        # parse the ADS HTML file
        ads = ADSHTMLParser(prefs=prefs)
        ads.parse(adsURL)
        # pdf local file, title, first author, abstract, bibtex code
        # UTF-8 encoded
        print ''.join(map(lambda x: x.encode('utf-8'), [ads.getPDF(), '|||',
                                                        ads.title, '|||',
                                                        ads.author[0], '|||',
                                                        ads.abstract, '|||',
                                                        ads.bibtex.__str__()]))


def parseURL(in_url, prefs):

    # let in_url be a local file with 
    # the contents of the ADS page
    if os.path.isfile(in_url):
        return open(in_url).read()

    url = urlparse.urlsplit(in_url)
    # identifier (no URL)
    if url.scheme == '':
        # ADS bibcode?
        adsURL = urlparse.urlunsplit(('http', prefs['ads_mirror'], 'abs/%s' % in_url, '', ''))
        if prefs['debug']:
            print 'ADS', adsURL
        try:
            # don't waste a perfectly good urlopen
            adsURL = urllib2.urlopen(adsURL).read()
        except urllib2.HTTPError:
            # arXiv identifier?
            arxivURL = urlparse.urlunsplit(('http', 'arxiv.org', 'abs/%s' % in_url, '', ''))
            if prefs['debug']:
                print 'arXiv', arxivURL
            try:
                # test existence of arXiv page
                urllib2.urlopen(arxivURL).read()
                # ADS page corresponding to the arXiv identifier
                adsURL = urlparse.urlunsplit(('http', prefs['ads_mirror'], 'cgi-bin/bib_query',
                                              'arXiv:%s' % in_url, ''))
            # something's wrong
            except urllib2.HTTPError:
                return None

    # arXiv URL
    elif 'arxiv' in url.netloc:
        # get paper identifier from URL and inject into ADS query
        arxivid = '/'.join(url.path.split('/')[2:]),
        adsURL = urlparse.urlunsplit(('http', prefs['ads_mirror'], 'cgi-bin/bib_query',
                                      'arXiv:%s' % arxivid, ''))

    # we have a nice ADS abstract page entry
    elif url.netloc in prefs.adsmirrors:
        adsURL = in_url

    # we're in trouble here
    else:
        return None

    return adsURL


class Preferences(object):
    """Manages the preferences on disk and in memory. Preferences are accessed
    with by a dictionary-like interface.
    """

    def __init__(self):
        self.prefsPath = os.path.join(os.getenv('HOME'), '.adsbibdesk')
        self._adsmirrors = ['adsabs.harvard.edu',
                            'cdsads.u-strasbg.fr',
                            'ukads.nottingham.ac.uk',
                            'esoads.eso.org',
                            'ads.ari.uni-heidelberg.de',
                            'ads.inasan.ru',
                            'ads.mao.kiev.ua',
                            'ads.astro.puc.cl',
                            'ads.on.br',
                            'ads.nao.ac.jp',
                            'ads.bao.ac.cn',
                            'ads.iucaa.ernet.in',
                            'www.ads.lipi.go.id']

        self.prefs = self._getDefaultPrefs() # Hard coded defaults dictionary
        newPrefs = self._getPrefs() # load user prefs from disk
        self.prefs.update(newPrefs) # override defaults with user prefs
        self._keys = self.prefs.keys()
        self._iterIndex = -1

    def __getitem__(self, key):
        return self.prefs[key]

    def __setitem__(self, key, value):
        self.prefs[key] = value
        self._keys = self.prefs.keys()

    def __iter__(self):
        return self

    def next(self):
        if self._iterIndex == len(self._keys)-1:
            self._iterIndex = -1
            raise StopIteration
        self._iterIndex += 1
        return self._keys[self._iterIndex]

    def _getDefaultPrefs(self):
        """:return: a dictionary of the full set of default preferences. This
        is done in case the user's preference file is missing a key-value pair.
        """
        return {"ads_mirror": "adsabs.harvard.edu",
                "arxiv_mirror": None,
                "download_pdf": True,
                "ssh_user": None,
                "ssh_server": None,
                "debug": False}

    def _getPrefs(self):
        """Read preferences files from `self.prefsPath`, creates one otherwise."""
        prefs = {}
        # create a default preference file if non existing
        if not os.path.exists(self.prefsPath):
            self._writeDefaultPrefs()

        for l in open(self.prefsPath):
            if l.strip() and not l.strip().startswith('#'):
                if '=' not in l:
                    # badly formed setting
                    continue
                k, v = l.strip().split('=')
                if not v:
                    v = None
                elif v.strip().lower() in ('true', 'yes'):
                    v = True
                elif v.strip().lower() in ('false', 'no'):
                    v = False
                elif v.strip().lower() == 'none':
                    v = None
                prefs[k] = v

        return prefs

    def _writeDefaultPrefs(self):
        """
        Set a default preferences file (~/.adsbibdesk)
        """
        prefs = open(self.prefsPath, 'w')
        print &gt;&gt; prefs, """# ADS mirror
ads_mirror=%s

# arXiv mirror
# (leave it unset to use the arXiv mirror pointed by your ADS mirror)
arxiv_mirror=%s

# download PDFs?
download_pdf=%s

# set these to use your account on a remote machine for fetching
# (refereed) PDF's you have no access locally
ssh_user=%s
ssh_server=%s""" % (self.prefs['ads_mirror'], self.prefs['arxiv_mirror'],
                    self.prefs['download_pdf'], self.prefs['ssh_user'],
                    self.prefs['ssh_server'])

        prefs.close()

    @property
    def adsmirrors(self):
        return self._adsmirrors


class BibTex:

    def __init__(self, url):
        """
        Create BibTex instance from ADS BibTex URL
        """
        bibtex = urllib2.urlopen(url).readlines()
        bibtex = ' '.join([l.strip() for l in bibtex]).strip()
        bibtex = bibtex[re.search('@[A-Z]+\{', bibtex).start():]
        self.type, self.bibcode, self.info = self.parsebib(bibtex)

    def __str__(self):
        return ','.join(['@' + self.type + '{' + self.bibcode] + ['%s=%s' % (i, j) for i, j in self.info.items()]) + '}'

    def parsebib(self, bibtex):
        """
        Parse bibtex code into dictionary
        """
        r = re.search('(?&lt;=^@)(?P&lt;type&gt;[A-Z]+){(?P&lt;bibcode&gt;\S+)(?P&lt;info&gt;,.+)}$', bibtex)
        s = re.split('(,\s\w+\s=\s)', r.group('info'))
        info = dict([(i[1:].replace('=', '').strip(), j.strip()) for i, j in zip(s[1::2], s[2::2])])
        return r.group('type'), r.group('bibcode'), info


class ADSException(Exception):
    pass


class ADSHTMLParser(HTMLParser):

    def __init__(self, *args, **kwargs):
        HTMLParser.__init__(self)
        self.links = {}
        self.tag = ''
        self.get_abs = False
        self.entities = {}

        self.bibtex = None
        self.abstract = None
        self.title = ''
        self.author = []

        self.prefs = kwargs.get('prefs', {}) # Use an empty dictionary instead... or just create an empty Preferences instance?

    def mathml(self):
        """
        Generate dictionary with MathML -&gt; unicode conversion from
        http://www.w3.org/Math/characters/byalpha.html
        """
        w3 = 'http://www.w3.org/Math/characters/byalpha.html'
        mathml = re.search('(?&lt;=&lt;pre&gt;).+(?=&lt;/pre&gt;)', urllib2.urlopen(w3).read(), re.DOTALL).group()
        entities = {}
        for l in mathml[:-1].split('\n'):
            s = l.split(',')
            #ignore double hex values like 'U02266-00338'
            if '-' not in s[1]:
                #hexadecimal -&gt; int values, for unichr
                entities[s[0].strip()] = int(s[1].strip()[1:], 16)
        return entities

    def parse(self, url):
        """
        Feed url into our own HTMLParser and parse found bibtex
        """
        try:
            self.feed(url.startswith('http') and urllib2.urlopen(url).read() or url)
        # HTTP timeout
        except urllib2.URLError, err:
            if self.prefs['debug']:
                print '%s timed out' % url
            raise ADSException(err)

        #parse bibtex
        if self.prefs['debug']:
            print "ADSHTMLParser links:",
            print self.links
        if 'bibtex' in self.links:
            self.bibtex = BibTex(self.links['bibtex'])
            self.title = re.search('(?&lt;={).+(?=})', self.bibtex.info['title']).group().replace('{', '').replace('}', '')
            self.author = [a.strip() for a in
                           re.search('(?&lt;={).+(?=})', self.bibtex.info['author']).group().split(' and ')]

    def handle_starttag(self, tag, attrs):
        #abstract
        if tag.lower() == 'hr' and self.get_abs:
            self.abstract = self.tag.strip().decode('utf-8')
            self.get_abs = False
            self.tag = ''
        #handle old scanned articles abstracts
        elif tag.lower() == 'img' and self.get_abs:
            self.tag += dict(attrs)['src'].replace('&amp;#38;', unichr(38))
        #links
        elif tag.lower() == 'a':
            if 'href' in dict(attrs):
                href = dict(attrs)['href'].replace('&amp;#38;', unichr(38))
                query = cgi.parse_qs(urlparse.urlsplit(href).query)
                if 'bibcode' in query:
                    if 'link_type' in query:
                        self.links[query['link_type'][0].lower()] = href
                    elif 'data_type' in query:
                        self.links[query['data_type'][0].lower()] = href

    def handle_data(self, data):
        if self.get_abs:
            self.tag += data.replace('\n', ' ')

        #beginning of abstract found
        if data.strip() == 'Abstract':
            self.get_abs = True

    #handle html entities
    def handle_entityref(self, name):
        if self.get_abs:
            if name in name2codepoint:
                c = name2codepoint[name]
                self.tag += unichr(c).encode('utf-8')
            else:
                #fetch mathml
                if not self.entities:
                    #cache dict
                    self.entities = self.mathml()
                if name in self.entities:
                    c = self.entities[name]
                    self.tag += unichr(c).encode('utf-8')
                else:
                    #nothing worked, leave it as-is
                    self.tag += '&amp;' + name + ';'

    #handle unicode chars in utf-8
    def handle_charref(self, name):
        if self.get_abs:
            self.tag += unichr(int(name)).encode('utf-8')

    def getPDF(self):
        """
        Fetch PDF and save it locally in a temporary file.
        Tries by order:
        - refereed article
        - refereed article using another machine (set ssh_user &amp; ssh_server)
        - arXiv preprint
        - electronic journal link
        """
        if not self.links:
            return 'failed'
        elif 'download_pdf' in self.prefs and not self.prefs['download_pdf']:
            return 'not downloaded'

        def filetype(filename):
            return sp.Popen('file %s' % filename, shell=True,
                            stdout=sp.PIPE,
                            stderr=sp.PIPE).stdout.read()

        # refereed
        if 'article' in self.links:
            url = self.links['article']
            # try locally
            pdf = tempfile.mktemp() + '.pdf'
            # test for HTTP auth need
            try:
                open(pdf, 'wb').write(urllib2.urlopen(url).read())
            except urllib2.HTTPError:
                # dummy file
                open(pdf, 'w').write('dummy')

            if 'PDF document' in filetype(pdf):
                return pdf

            # try in remote server
            # you need to set SSH public key authentication for this to work!
            elif 'ssh_user' in self.prefs and self.prefs['ssh_user'] is not None:
                pdf = tempfile.mktemp() + '.pdf'
                cmd = 'ssh %s@%s \"touch adsbibdesk.pdf; wget -O adsbibdesk.pdf \\"%s\\"\"' % (self.prefs['ssh_user'], self.prefs['ssh_server'], url)
                cmd2 = 'scp -q %s@%s:adsbibdesk.pdf %s' % (self.prefs['ssh_user'], self.prefs['ssh_server'], pdf)
                sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE).communicate()
                sp.Popen(cmd2, shell=True, stdout=sp.PIPE, stderr=sp.PIPE).communicate()
                if 'PDF document' in filetype(pdf):
                    return pdf

        # arXiv
        if 'preprint' in self.links:
            # arXiv page
            url = self.links['preprint']
            mirror = None
            for line in urllib2.urlopen(url):
                if '&lt;h1&gt;&lt;a href="/"&gt;' in line:
                    mirror = re.search('&lt;h1&gt;&lt;a href="/"&gt;(.*ar[xX]iv.org)', line)
                elif 'dc:identifier' in line:
                    begin = re.search('dc:identifier="', line).end()
                    url = urlparse.urlsplit(line[begin:-2].replace('&amp;#38;', unichr(38)).lower())
                    # use automatic mirror chosen by the ADS mirror
                    if ('arxiv_mirror' not in self.prefs or not self.prefs['arxiv_mirror']) and mirror is not None:
                        url = urlparse.urlunsplit((url.scheme, mirror.group(1), url.path, url.query, url.fragment))
                    elif self.prefs['arxiv_mirror']:
                        url = urlparse.urlunsplit((url.scheme, self.prefs['arxiv_mirror'], url.path, url.query, url.fragment))
                    # get arXiv PDF
                    pdf = tempfile.mktemp() + '.pdf'
                    open(pdf, 'wb').write(urllib2.urlopen(url.replace('abs', 'pdf')).read())
                    if 'PDF document' in filetype(pdf):
                        return pdf
                    else:
                        return url

        #electronic journal
        if 'ejournal' in self.links:
            return self.links['ejournal']

        return 'failed'


if __name__ == '__main__':
    main()
</string>
					<key>CheckedForUserDefaultShell</key>
					<true />
					<key>inputMethod</key>
					<integer>1</integer>
					<key>shell</key>
					<string>/usr/bin/python</string>
					<key>source</key>
					<string />
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.RunShellScript</string>
				<key>CFBundleVersion</key>
				<string>2.0.1</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false />
				<key>CanShowWhenRun</key>
				<true />
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunShellScriptAction</string>
				<key>InputUUID</key>
				<string>6E230052-C440-4495-826E-50AB36C5E948</string>
				<key>Keywords</key>
				<array>
					<string>Shell</string>
					<string>Script</string>
					<string>Command</string>
					<string>Run</string>
					<string>Unix</string>
				</array>
				<key>OutputUUID</key>
				<string>6D4B960E-FAA0-40BE-970D-0966B873A4FB</string>
				<key>UUID</key>
				<string>F9F2D720-3CC6-4C60-B7D8-02981C8B8B63</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>inputMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<string />
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<false />
						<key>name</key>
						<string>CheckedForUserDefaultShell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string />
						<key>name</key>
						<string>COMMAND_STRING</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
					<key>4</key>
					<dict>
						<key>default value</key>
						<string>/bin/sh</string>
						<key>name</key>
						<string>shell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>4</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true />
				<key>location</key>
				<string>420.500000:639.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run Shell Script.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true />
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true />
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict />
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>--ADS to BibDesk -- frictionless import of ADS publications into BibDesk
--Copyright (C) 2009  Rui Pereira &lt;rui.pereira@gmail.com&gt;
--
--This program is free software: you can redistribute it and/or modify
--it under the terms of the GNU General Public License as published by
--the Free Software Foundation, either version 3 of the License, or
--(at your option) any later version.
--
--This program is distributed in the hope that it will be useful,
--but WITHOUT ANY WARRANTY; without even the implied warranty of
--MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--GNU General Public License for more details.
--
--You should have received a copy of the GNU General Public License
--along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
--
--  Based on:
--  AppleScript to convert downloaded Bibtex and abstract information to a BibDesk entry.
--  Jonathan Sick, jonathansick@mac.com, August 2007

on growlNotification(titlestr, descstr)
	tell application "System Events"
		--Growl is running
		if (count of (every process whose name is "GrowlHelperApp")) &gt; 0 then
			tell application "GrowlHelperApp"
				register as application "BibDesk" all notifications {"BibDesk notification"} default notifications {"BibDesk notification"}
				notify with name "BibDesk notification" title titlestr description descstr application name "BibDesk" priority 0 without sticky
			end tell
		end if
	end tell
end growlNotification

on safeDelete(thePub)
	tell document 1 of application "BibDesk"
		tell thePub
			--remove PDFs
			repeat with theFile in (linked files whose POSIX path does not contain "_skim_")
				if POSIX path of theFile ends with ".pdf" then
					-- keep backup with Skim notes
					if Skim notes of theFile is not {} then
						tell application "Finder"
							set theSuffix to 1
							set thePath to (container of file theFile as string)
							set AppleScript's text item delimiters to "."
							set tmpName to items 1 thru -2 of (text items of (name of file theFile as string)) as string
							set AppleScript's text item delimiters to ""
							-- find a non-existing backup name
							repeat
								set backupName to tmpName &amp; "_skim_" &amp; theSuffix &amp; ".pdf"
								if not (item (thePath &amp; backupName) exists) then exit repeat
								set theSuffix to theSuffix + 1
							end repeat
							-- change file name (BibDesk will properly reference it automatically)
							set name of file theFile to backupName
						end tell
						-- delete PDFs without Skim notes
					else
						tell application "Finder"
							delete file theFile
						end tell
					end if
				end if
			end repeat
		end tell
		delete thePub
	end tell
end safeDelete

on findSkimFiles(thePub)
	tell document 1 of application "BibDesk"
		tell thePub
			repeat with theFile in (linked files whose POSIX path does not contain "_skim_")
				set AppleScript's text item delimiters to "/"
				set fileName to last text item of POSIX path of theFile
				set AppleScript's text item delimiters to "."
				set theName to items 1 thru -2 of (text items of fileName) as string
				tell application "Finder"
					-- POSIX path may work here also...
					set AppleScript's text item delimiters to ":"
					set tmp to text items 2 thru -1 of (container of file theFile as string)
					set AppleScript's text item delimiters to "/"
					set thePath to "/" &amp; (tmp as string)
					-- use shell (applescript is way too slow for this)
					set cmd to "ls " &amp; thePath &amp; "*" &amp; theName &amp; "*skim*pdf | xargs"
					try
						set AppleScript's text item delimiters to " "
						set skimFiles to text items of (do shell script cmd)
						set AppleScript's text item delimiters to ""
					on error
						set skimFiles to {}
					end try
				end tell
			end repeat
		end tell
	end tell
	return skimFiles
end findSkimFiles

on run input
	
	set AppleScript's text item delimiters to " "
	set input to (input as text)
	set AppleScript's text item delimiters to "|||"
	set thePDFFile to (text item 1 of input)
	set theTitle to (text item 2 of input)
	set theAuthor to (text item 3 of input)
	set theAbstract to (text item 4 of input)
	set theBibEntry to (text item 5 of input)
	set AppleScript's text item delimiters to ""
	
	tell document 1 of application "BibDesk"
		-- searchs for already existent publication with exactly the same title and first author
		if (count (search for theTitle)) &gt; 0 then
			--delete old one
			repeat with thePub in (search for theTitle)
				if (count (authors of thePub)) &gt; 0 and name of first author of thePub contains theAuthor then
					my safeDelete(thePub)
					my growlNotification("Duplicate publication removed", "\"" &amp; theTitle &amp; "\"")
				end if
			end repeat
		end if

		-- add new publication
		set thePub to first item of (import from theBibEntry)
		tell thePub
			set the cite key to generated cite key as string
			set myCiteKey to cite key
			-- old scanned articles
			if theAbstract starts with "http://" then
				make new linked URL with data (theAbstract as string) at end of linked URLs
			else
				set the abstract to theAbstract as string
			end if
			-- file found?
			if thePDFFile ends with ".pdf" then
				add (POSIX file thePDFFile) to beginning of linked files
				auto file
				-- this is not a file, but rather an URL
			else if thePDFFile is not "failed" then
				-- only add it if no DOI link present (they are very probably the same)
				if (value of field "doi" = "") then
					make new linked URL with data (thePDFFile as string) at end of linked URLs
				end if
			end if
			-- add old Skim files
			repeat with skimFile in my findSkimFiles(thePub)
				make new linked file with data skimFile at end of linked files
			end repeat
		end tell
	end tell
	
	-- growl
	my growlNotification("New publication added", "\"" &amp; theTitle &amp; "\" as " &amp; myCiteKey)
	
end run

</string>
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false />
				<key>CanShowWhenRun</key>
				<true />
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>InputUUID</key>
				<string>CFA2B4C5-5F51-4E63-849C-DDD77C7E414E</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>7A35A6BE-B95B-4ED0-A150-862DC6970F61</string>
				<key>UUID</key>
				<string>955038CD-F2CD-47C7-B1A5-6A3B4D3B2FF3</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true />
				<key>location</key>
				<string>420.500000:456.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true />
		</dict>
	</array>
	<key>connectors</key>
	<dict>
		<key>ABE6BEB3-C47A-4BD2-B15E-8262C963C818</key>
		<dict>
			<key>from</key>
			<string>F9F2D720-3CC6-4C60-B7D8-02981C8B8B63 - F9F2D720-3CC6-4C60-B7D8-02981C8B8B63</string>
			<key>to</key>
			<string>955038CD-F2CD-47C7-B1A5-6A3B4D3B2FF3 - 955038CD-F2CD-47C7-B1A5-6A3B4D3B2FF3</string>
		</dict>
		<key>D69CF8B5-0F8A-4B05-9B1F-5747692A150D</key>
		<dict>
			<key>from</key>
			<string>59A79AF9-E315-4B2F-995D-248D03F6B9F5 - 59A79AF9-E315-4B2F-995D-248D03F6B9F5</string>
			<key>to</key>
			<string>F9F2D720-3CC6-4C60-B7D8-02981C8B8B63 - F9F2D720-3CC6-4C60-B7D8-02981C8B8B63</string>
		</dict>
	</dict>
	<key>state</key>
	<dict>
		<key>AMLogTabViewSelectedIndex</key>
		<integer>0</integer>
		<key>libraryState</key>
		<dict>
			<key>actionsMajorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 381.000000, 816.000000, NO</string>
					<string>0.000000, 817.000000, 381.000000, 89.000000, NO</string>
				</array>
			</dict>
			<key>actionsMinorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 163.000000, 816.000000, NO</string>
					<string>164.000000, 0.000000, 217.000000, 816.000000, NO</string>
				</array>
			</dict>
			<key>variablesMajorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 381.000000, 555.000000, NO</string>
					<string>0.000000, 556.000000, 381.000000, 199.000000, NO</string>
				</array>
			</dict>
			<key>variablesMinorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 163.000000, 555.000000, NO</string>
					<string>164.000000, 0.000000, 217.000000, 555.000000, NO</string>
				</array>
			</dict>
		</dict>
		<key>majorSplitViewState</key>
		<dict>
			<key>expandedPosition</key>
			<real>381</real>
			<key>subviewState</key>
			<array>
				<string>0.000000, 0.000000, 0.000000, 951.000000, YES</string>
				<string>0.000000, 0.000000, 841.000000, 951.000000, NO</string>
			</array>
		</dict>
		<key>minorSplitViewState</key>
		<dict>
			<key>expandedPosition</key>
			<real>0.0</real>
			<key>subviewState</key>
			<array>
				<string>0.000000, 0.000000, 841.000000, 760.000000, NO</string>
				<string>0.000000, 770.000000, 841.000000, 162.000000, NO</string>
			</array>
		</dict>
		<key>windowFrame</key>
		<string>{{0, 0}, {840, 1028}}</string>
		<key>workflowViewScrollPosition</key>
		<string>{{0, 0}, {841, 760}}</string>
	</dict>
	<key>workflowMetaData</key>
	<dict>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.application</string>
	</dict>
</dict>
</plist>